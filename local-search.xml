<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据大屏搭建与开发的秘诀</title>
    <link href="/2023/10/31/20131031_1/"/>
    <url>/2023/10/31/20131031_1/</url>
    
    <content type="html"><![CDATA[<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><img src="/../assets/20131031/watermark.png"></p><h2 id="一-拆分组件"><a href="#一-拆分组件" class="headerlink" title="一. 拆分组件"></a>一. 拆分组件</h2><p>根据ui图，创建合适的目录结构，划分合理的组件，UI图分为左中右三部分，同时又有头部，所以我将组件这样拆分</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5d44888284242a3b1c4a9868838a47e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>index.vue 为父组件，左中右以及头部为子组件，<code>enterprise</code> 目录是中间地图上方的内容，由于和地图各自独立我也单独拆分为一个组件，用绝对定位放在地图上方，当中间地图区域有交互效果时只需要将上层元素加一段css代码<br><strong>pointer-events: none</strong>,允许点击穿透即可。组件拆分完成，接下来针对每一部分组件单独开发。</p><h2 id="二-大屏适配"><a href="#二-大屏适配" class="headerlink" title="二. 大屏适配"></a>二. 大屏适配</h2><p>大屏适配方案比较多，因项目而异，我这个项目中UI是32：9的尺寸，以我的项目为例，如果屏幕尺寸固定和UI一致，直接写死宽高<br>如果屏幕大小不一，且仍需按照32：9的比例显示，我们做动态匹配<br>给外层div绑定ref</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02b743507b854b13a296c4a31cc24418~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><pre><code class="hljs">    import throttle from &#39;lodash.throttle&#39;;    onMounted(() =&gt; &#123;      if (dataScreenRef.value) &#123;        dataScreenRef.value.style.transform = `scale($&#123;getScale()&#125;) translate(-50%, -50%) `;        dataScreenRef.value.style.width = `$&#123;width&#125;px`;        dataScreenRef.value.style.height = `$&#123;height&#125;px`;      &#125;      window.addEventListener(&#39;resize&#39;, resize);    &#125;);    const dataScreenRef: any = ref(null);    // 数据大屏自适应函数    const width = 3840;    const height = 1080;    const getScale = (w = width, h = height) =&gt; &#123;      let ww = window.innerWidth / w;      let wh = window.innerHeight / h;      return ww &lt; wh ? ww : wh;    &#125;;    /* 浏览器监听 resize 事件 */    const resize = () =&gt; &#123;      if (dataScreenRef.value) &#123;        throttle(          (dataScreenRef.value.style.transform = `scale($&#123;getScale()&#125;) translate(-50%, -50%) transform-origin: top left;`),          200,        );      &#125;    &#125;;</code></pre><h2 id="三-组件图表开发"><a href="#三-组件图表开发" class="headerlink" title="三. 组件图表开发"></a>三. 组件图表开发</h2><p>布局和适配完成之后，进行内容开发，大屏技术栈主要应用Echarts，这里我用到了自己封装的 <a href="https://www.npmjs.com/package/base-echarts?activeTab=readme">Echarts</a>插件 base-echarts。</p><h3 id="一-使用base-echarts构建图表"><a href="#一-使用base-echarts构建图表" class="headerlink" title="一. 使用base-echarts构建图表"></a>一. 使用base-echarts构建图表</h3><p>用到base-echarts之后，开发效率大幅提升。</p><ol><li><p>先搭完组件的整体框架，用空盒子实现区块划分</p></li><li><p>下载安装base-echarts之后，引入<code>BaseEcharts</code></p></li></ol><!----><pre><code class="hljs">npm install base-echarts@latestimport &#123; BaseEcharts &#125; from &#39;base-echarts&#39;;</code></pre><ol start="3"><li>使用</li></ol><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/168a75368fcc4889a91ce023180b06e5~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>如果外层盒子，charts-box有自己的宽高，我们需要图表撑满charts-box这个盒子，BaseEcharts可以不传宽高，默认宽高100%</p><h3 id="二-将图表配置封装成hooks"><a href="#二-将图表配置封装成hooks" class="headerlink" title="二. 将图表配置封装成hooks"></a>二. 将图表配置封装成hooks</h3><p>由于一个组件中有大量图表，太多的options加上接口api，十分冗余，难以维护，为每一个组件创建一个hooks，把options集中存放</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d1392f2ceb349d4bdff25ce4a17c5be~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce7bf513aa7041cfa311566b97bd46d5~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="三-接口调用"><a href="#三-接口调用" class="headerlink" title="三. 接口调用"></a>三. 接口调用</h3><p>在绑定的的options函数中调用接口，将拿到的数据赋值给函数内的局部变量option，option用ref包裹，这样由于vue3响应式的特点，当接口的参数改变之后会触发函数重新赋值，省去了侦听这一步。<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcd99c0f2b84494c974005be338ed29c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>完成上述步骤之后，项目雏形基本实现，接下来就是根据更细致的需求做一些缝缝补补的工作。</p><h3 id="四-视觉动态效果"><a href="#四-视觉动态效果" class="headerlink" title="四. 视觉动态效果"></a>四. 视觉动态效果</h3><blockquote><ol><li>每隔5分钟图表重新渲染，目的就是要看渲染的动画效果，给人一种数据实时更新的感觉😂</li></ol></blockquote><p>思路：这么多数据不可能每隔五分钟调一遍接口，对option重新赋值，想到echarts的渲染动画应该是在<code>setOptions</code>这一步执行渲染的，那是不是重新执行<code>myEcharts.setOptions(options)</code>就可以了呢。</p><p>实现：使用base-echarts的同时执行<code>setOptions</code>方法，需要给BaseEcharts组件绑定ref，通过ref调用<code>setOptions</code></p><pre><code class="hljs">&lt;BaseEcharts  :height=&quot;&#39;167px&#39;&quot;  :options=&quot;options&quot;  ref=&quot;opt&quot;  :istool=&quot;true&quot;  :interval=&quot;6000&quot;/&gt;&lt;script setup&gt;    import &#123;ref, onMounted&#125;    const opt = ref(null)    onMounted(()=&gt;&#123;        setInterval(() =&gt; &#123;            opt.value.setOptions(options.value)        &#125;, 300000)    &#125;)&lt;/script&gt;</code></pre><p>这样实现，图表一动不动。因为echarts只有在数据改变的时候才会重新渲染，而我们执行setOptions时，数据没有发生改变。<br>在不改变原始数据的前提下要实现我们的目的，我们可以将echarts图表清空或者将图表销毁再执行。</p><p>使用BaseEcharts清空图表需要通过 echartInstance()方法 获取图表echartInstance实例调用他上面的clear()方法，echartInstance上的具体方法可查看<a href="https://echarts.apache.org/zh/api.html#echarts">官网</a></p><pre><code class="hljs">opt.value.echartInstance().clear(); // 清空图表opt.value.echartInstance().dispose(); // 销毁实例</code></pre><p>这里我们使用clear即可，销毁实例还是轻易不要尝试</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12d61592ff214cf99ad4742529502282~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38e1a6f1dede491bafbcb7dfd03c0026~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><blockquote><ol start="2"><li>让 图表的 tooltip悬浮框自动播放 😎</li></ol></blockquote><p>直接配置 BaseEcharts，<code>:istool=&#39;true&#39;</code> 开启轮播，“什么？速度太快”，直接配置 BaseEcharts，<code>:interval=&#39;6000&#39;</code></p><blockquote><ol start="3"><li>数字滚动效果也加一个吧 😐</li></ol></blockquote><p>推荐使用用插件，<code>vue3-count-to</code></p><blockquote><ol start="4"><li>antd样式自定义</li></ol></blockquote><p>自定义？真懒得动弹，翻出之前封装的一个调调的antd ui库，拿来直接用吧（这里我不推荐大家使用了，局限性很大）</p><pre><code class="hljs">npm install dw-dark-uiimport &#39;dw-dark-ui/dw-dark-ui/style.css&#39;;</code></pre><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/836b2753d784409cb7f88d84136510ef~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h2 id="最终呈现"><a href="#最终呈现" class="headerlink" title="最终呈现"></a>最终呈现</h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05ceff46ac724aa28becc99dded80eb1~tplv-k3u1fbpfcp-watermark.image" alt="20230602_170852 (1).gif"></p><p>希望这篇文章能给用到的人带来帮助。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/10/31/hello-world/"/>
    <url>/2023/10/31/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
